import React, { createContext, useContext, useState } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

const PaymentContext = createContext();

export const PaymentProvider = ({ children }) => {
  const [payments, setPayments] = useState([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [paymentError, setPaymentError] = useState('');

  // Process payment
  const processPayment = async (paymentData) => {
    setIsProcessing(true);
    setPaymentError('');
    
    try {
      const payment = {
        id: Date.now().toString(),
        amount: paymentData.amount,
        method: paymentData.method, // 'paypal', 'visa', 'crypto'
        status: 'pending', // pending, completed, failed
        bookingId: paymentData.bookingId,
        description: paymentData.description,
        timestamp: new Date().toISOString(),
      };

      // Mock payment processing - в реальном приложении будет реальная интеграция
      await new Promise(resolve => setTimeout(resolve, 2000));

      payment.status = 'completed';
      payment.transactionId = 'TXN_' + Date.now();

      const updated = [payment, ...payments];
      setPayments(updated);
      
      // Save to storage
      await AsyncStorage.setItem('@payments', JSON.stringify(updated));

      // Track payment in analytics (will be injected via context)
      // This can be hooked up with AnalyticsContext later

      return payment;
    } catch (error) {
      setPaymentError(error.message || 'Payment processing failed');
      throw error;
    } finally {
      setIsProcessing(false);
    }
  };

  // Process PayPal payment
  const processPayPalPayment = async (amount, bookingId, description) => {
    try {
      // Simulate PayPal payment
      // В реальности здесь будет вызов PayPal SDK
      return processPayment({
        amount,
        method: 'paypal',
        bookingId,
        description,
      });
    } catch (error) {
      throw error;
    }
  };

  // Process Visa/Stripe payment
  const processVisaPayment = async (cardToken, amount, bookingId, description) => {
    try {
      // Simulate Stripe payment
      // В реальности здесь будет вызов Stripe API
      return processPayment({
        amount,
        method: 'visa',
        bookingId,
        description,
        cardToken,
      });
    } catch (error) {
      throw error;
    }
  };

  // Process Crypto payment (Bitcoin, Ethereum, etc.)
  const processCryptoPayment = async (cryptoType, amount, bookingId, description) => {
    try {
      // Generate crypto payment address (mock)
      const cryptoPayment = {
        id: Date.now().toString(),
        amount,
        method: 'crypto',
        cryptoType, // 'bitcoin', 'ethereum', etc.
        status: 'pending',
        bookingId,
        description,
        timestamp: new Date().toISOString(),
        walletAddress: generateCryptoAddress(cryptoType),
        qrCode: null, // Will be generated by QR component
      };

      const updated = [cryptoPayment, ...payments];
      setPayments(updated);
      
      await AsyncStorage.setItem('@payments', JSON.stringify(updated));

      return cryptoPayment;
    } catch (error) {
      setPaymentError(error.message || 'Crypto payment setup failed');
      throw error;
    }
  };

  // Generate mock crypto address
  const generateCryptoAddress = (cryptoType) => {
    const addresses = {
      bitcoin: '1A1z7agoat2YLZW51Bc7M8' + Math.random().toString(36).substr(2, 10),
      ethereum: '0x' + Math.random().toString(16).substr(2, 40),
      usdt: '0x' + Math.random().toString(16).substr(2, 40),
    };
    return addresses[cryptoType] || addresses.ethereum;
  };

  // Get payment status
  const getPaymentStatus = (paymentId) => {
    return payments.find(p => p.id === paymentId);
  };

  // Get all payments
  const getAllPayments = () => {
    return payments;
  };

  return (
    <PaymentContext.Provider value={{
      payments,
      isProcessing,
      paymentError,
      processPayment,
      processPayPalPayment,
      processVisaPayment,
      processCryptoPayment,
      getPaymentStatus,
      getAllPayments,
    }}>
      {children}
    </PaymentContext.Provider>
  );
};

export const usePayment = () => {
  const context = useContext(PaymentContext);
  if (!context) {
    throw new Error('usePayment must be used within PaymentProvider');
  }
  return context;
};
